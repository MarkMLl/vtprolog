#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{pifont}
\usepackage{textcomp}

% It appears that one has to use pdf(la)tex for the conversion, ps2pdf
% handles bookmarks but not thumbnails.

\usepackage[pdftex,bookmarks=true,bookmarksnumbered=true,colorlinks,linkcolor=blue]{hyperref}
\usepackage[pdftex]{thumbpdf}

% Generating thumbs also requires the thumbpdf Perl script., e.g.
%
% cd ~/links/product_documentation/vt_prolog
% /usr/share/texmf/bin/thumbpdf --modes=pdftex vt_prolog1.pdf
%
% followed by a rerun of the export sequence.

\hypersetup{
  pdfauthor={Bill Thompson and Bev Thompson. Typeset Mark Morgan Lloyd},
  pdftitle={PROLOG From the Bottom Up},
  pdfsubject={PROLOG From the Bottom Up},
  pdfkeywords={PROLOG, VT-PROLOG},
  pdfcreator={LyX, LaTeX with hyperref and thumbpdf packages}
}

% Manually-installed initial-caps fonts from
% http://www.ctan.org/tex-archive/fonts/initials or
% Debian's texlive-fonts-extra package.

\usepackage{type1cm}
\usepackage{lettrine}
\input Typocaps.fd

\usepackage{multicol}
\end_preamble
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 0.75in
\topmargin 0.5in
\rightmargin 0.5in
\bottommargin 0.5in
\headheight 0.25in
\headsep 0.25in
\footskip 0.25in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title

\size larger
PROLOG From the Bottom Up
\end_layout

\begin_layout Author

\size larger
By Bill Thompson and Bev Thompson
\begin_inset Foot
status open

\begin_layout Plain Layout
\noindent
Originally published in AI Expert, September 1986.
 Revised and typeset by Mark Morgan Lloyd, January 2010.
 Original authors' copyright reserved.
\end_layout

\end_inset


\end_layout

\begin_layout Date
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Dummy 'Date' paragraph.
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "85col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename FGCS_computer-pim-m-1.eps
	lyxscale 75
	scale 75
	keepAspectRatio

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
The Japanese Fifth Generation Computer Systems project uses a PROLOG derivative
 as its fundamental programming language in an attempt to undercut the dominance
 of American and European manufacturers.
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength{
\backslash
columnseprule}{0.25pt}
\backslash
begin{multicols}{2}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lettrine[lines=3,findent=1pt]{
\backslash
fontsize{30pt}{30pt}
\backslash
usefont{U}{Typocaps}{xl}{n}S}{ince}
\end_layout

\end_inset

 AI is such a new field, very few have had the opportunity of the apprentice
 to study under a master craftsman.
 Except for those working in large university and corporate AI labs, most
 of us who are interested in AI are working in relative isolation, hungrily
 devouring all of the books, articles, and inexpensive software we can get
 our hands on.
\end_layout

\begin_layout Standard
In this column we would like to become your colleagues in the exchange of
 ideas, techniques, and information about resources.
 We hope that as we share our ideas with you, you will do the same with
 us.
 If you have a better solution to a problem than the one we present, let
 us know.
 Also, if you have a problem that is of general interest, or an unusual
 technique, by all means send it along.
\end_layout

\begin_layout Standard
We are planning to use actual code in presenting new programming techniques.
 In the column itself we will print chunks of code, and at time we will
 make programs available on the bulletin boards listed on page 
\begin_inset CommandInset ref
LatexCommand pageref
reference "Resources"

\end_inset

.
 Since we're gearing this column to those who, like us, come from the more
 traditional programming backgrounds, we've decided to work primarily in
 Pascal.
 This seems like a good choice not only because it's a good teaching language
 but also because it's familiar to most C and Modula programmers.
 As with everything else, our direction will be heavily influenced by your
 opinions, so be sure to be free with them.
\end_layout

\begin_layout Standard
We've always had the idea that one of the most effective ways to learn a
 new programming language is to write a program that implements part of
 the language.
 In our first two columns, we will describe a very basic implementation
 of PROLOG.
 Our focus in the first article is not how to program in PROLOG but how
 PROLOG operates and what features distinguish it from more conventional
 programming languages.
 In the next column we will discuss the programming structures that are
 used to implement those features.
 This will not only provide you with a valuable look inside the language
 but will also demonstrate some interesting Pascal programming techniques.
\end_layout

\begin_layout Standard
You adventuresome souls who want to get a jump on the next column may want
 to download the completed VT-PROLOG (very tiny) interpreter written in
 Turbo Pascal, which is available on the bulletin boards.
\end_layout

\begin_layout Subsubsection*
A SIMPLE EXAMPLE
\end_layout

\begin_layout Standard
We will begin to try to understand how PROLOG operates by examining a simple
 example.
 Consider a collection of sentences.
 The sentences consist of single lowercase letters, called facts, or more
 complicated structures, called rules.
 The rules consist of a single lowercase letter and a special symbol ( :-
 ), followed by a fact or series of facts separated by commas.
 Each sentence is terminated by a period.
 This collection of sentences is called a data base.
 The following is a sample data base:
\end_layout

\begin_layout Enumerate
a
\begin_inset space ~
\end_inset

:- b,c,d.
\end_layout

\begin_layout Enumerate
a
\begin_inset space ~
\end_inset

:- e,f.
\end_layout

\begin_layout Enumerate
c.
\end_layout

\begin_layout Enumerate
d.
\end_layout

\begin_layout Enumerate
e.
\end_layout

\begin_layout Enumerate
f.
\end_layout

\begin_layout Enumerate
g
\begin_inset space ~
\end_inset

:- e,f.
\end_layout

\begin_layout Standard
The numbers aren't part of the data base, they are merely for our convenience.
 Line 1 can be read 
\begin_inset Quotes eld
\end_inset


\shape italic
a
\shape default
 is true if 
\shape italic
b
\shape default
 is true and 
\shape italic
c
\shape default
 is true and 
\shape italic
d
\shape default
 is true.
\begin_inset Quotes erd
\end_inset

 Line 3 says 
\begin_inset Quotes eld
\end_inset


\shape italic
c
\shape default
 is true.
\begin_inset Quotes erd
\end_inset

 The 
\shape italic
a
\shape default
s, 
\shape italic
b
\shape default
s etc.
 can stand for objects in the real world, but since PROLOG programs manipulate
 symbols and not their meaning, we will not confuse the issue by attaching
 an explicit meaning to each symbol.
 In line 1, 
\shape italic
a
\shape default
 is called the head and 
\shape italic
b,c,d
\shape default
 is called the tail of the rule.
 Line 3 has a head but no tail.
 The commas in rules stand for the word 
\begin_inset Quotes eld
\end_inset

and.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This data base might not seem particularly useful, but it is still possible
 to perform some interesting operations upon it.
 For instance, we might like to ask some questions about its contents.
 We can see that 
\shape italic
c
\shape default
 is true within the data base, but what about 
\shape italic
a
\shape default
 and 
\shape italic
e
\shape default
? Are facts 
\shape italic
a
\shape default
 and 
\shape italic
e
\shape default
 both true within this data base? A question about the data base is called
 a query.
 We write this query as 
\shape italic
a,e
\shape default
.
 It is easy to examine the data base and see if 
\shape italic
a,e
\shape default
 is true, but as the data base becomes larger and the queries become more
 complicated.
 a systematic method of searching the data base will be necessary.
 We can develop this method by noticing a couple of facts.
 First, an empty query (symbolised by 
\shape italic
NIL
\shape default
) is always true.
 Second, if the head of the query and the head of the rule match, replacing
 the head of the query by the tail of the rule doesn't change whether the
 query is true or false.
\end_layout

\begin_layout Standard
The second statement may require a little explanation.
 To prove the query 
\shape italic
a,e
\shape default
., we notice that line 1 of the data base says that 
\shape italic
a
\shape default
 is true if 
\shape italic
b
\shape default
, 
\shape italic
c
\shape default
, and 
\shape italic
d
\shape default
 are true.
 In other words, 
\shape italic
a,e.

\shape default
 is true if 
\shape italic
b
\shape default
, 
\shape italic
c
\shape default
, and 
\shape italic
d
\shape default
 are true and 
\shape italic
e
\shape default
 is true.
 That condition can be expressed by the query 
\shape italic
b,c,d,e.

\shape default
 If we can find a series of transformations such as this that reduce the
 query to 
\shape italic
NIL
\shape default
, then the original query was true.
\end_layout

\begin_layout Standard
One problem still remains with this method.
 Some transformations may lead to dead ends.
 For example, 
\shape italic
a,e.
\begin_inset space ~
\end_inset

=>
\begin_inset space ~
\end_inset

b,c,d,e.

\shape default
 will fail because no statement in the data base begins with 
\shape italic
b
\shape default
, so no further transformation is possible.
 In a case like this we back up to the query before the transformation and
 try the next rule.
 We only say that the query was false when all possible transformations
 of the original query have been exhausted.
 The process of backing up and trying a new rule is called backtracking.
\end_layout

\begin_layout Standard
We can express this a little more concisely with the pseudocode procedure
 shown in Listing 1
\begin_inset CommandInset ref
LatexCommand ref
reference "Listing 1"

\end_inset

.
 This pseudocode looks a great deal like Pascal, but we don't want to worry
 about things like data types for rules and queries yet so we will ignore
 them for the present.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{-1
\backslash
parskip}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "67col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
LISTING 1
\begin_inset CommandInset label
LatexCommand label
name "Listing 1"

\end_inset

: A procedure to solve queries.
\end_layout

\begin_layout Plain Layout

\lyxline

\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
\noindent
PROCEDURE solve(query) ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 VAR
\begin_inset Newline newline
\end_inset

  i : integer ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 BEGIN
\begin_inset Newline newline
\end_inset

  IF query = NIL
\begin_inset Newline newline
\end_inset

   THEN write('yes')
\begin_inset Newline newline
\end_inset

   ELSE
\begin_inset Newline newline
\end_inset

    FOR i := 1 TO max_rule_number DO
\begin_inset Newline newline
\end_inset

     IF head(rule[i]) = head(query)
\begin_inset Newline newline
\end_inset

      THEN solve( append( tail(rule[i]), tail(query) ) ) ;
\begin_inset Newline newline
\end_inset

END ; (* solve *)
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength{
\backslash
columnseprule}{0.25pt}
\backslash
begin{multicols}{2}
\end_layout

\end_inset

In Listing 1
\begin_inset CommandInset ref
LatexCommand ref
reference "Listing 1"

\end_inset

, 
\shape italic
rule[i]
\shape default
 is simply one line from the data base.
 
\shape italic
Head
\shape default
 is a function that returns the first item of either a sentence or a query.
 
\shape italic
Tail
\shape default
 returns everything in a sentence or query after the head.
 If there is nothing following the head, 
\shape italic
tail
\shape default
 returns 
\shape italic
NIL
\shape default
.
 
\shape italic
Append
\shape default
 is a procedure that merges pieces of rules and queries to produce a new
 query.
 For example, 
\shape italic
head(rule[1])
\shape default

\begin_inset space ~
\end_inset

=
\shape italic

\begin_inset space ~
\end_inset

a
\shape default
, 
\shape italic
tail(rule[1])
\shape default

\begin_inset space ~
\end_inset

=
\shape italic

\begin_inset space ~
\end_inset

b,c,d
\shape default
, and 
\shape italic
append(tail(rule[1]),tail(query))
\shape default

\begin_inset space ~
\end_inset

=
\shape italic

\begin_inset space ~
\end_inset

b,c,d,e
\shape default
.
 Appending 
\shape italic
NIL
\shape default
 to a query returns the original query: 
\shape italic
append(f,NIL)
\shape default

\begin_inset space ~
\end_inset

=
\shape italic

\begin_inset space ~
\end_inset

f
\shape default
.
 The 
\shape italic
solve
\shape default
 procedure is recursive; it calls itself with the transformed query.
 The recursion is terminated when either a query has been reduced to 
\shape italic
NIL
\shape default
 or the search of the data base for a particular query is exhausted.
\end_layout

\begin_layout Standard
To get a feeling for this process, let's examine the solution to the query
 
\shape italic
a,e.

\shape default
 in some detail.
 Listing 2
\begin_inset CommandInset ref
LatexCommand ref
reference "Listing 2"

\end_inset

 shows the calls to solve and the transformation of the queries.
 The indentation level represents the level of recursion.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{-1
\backslash
parskip}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "67col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
LISTING 2
\begin_inset CommandInset label
LatexCommand label
name "Listing 2"

\end_inset

: Calls to procedure 
\shape italic
solve
\shape default
 to answer query 
\shape italic
?-
\begin_inset space ~
\end_inset

a,e.
\end_layout

\begin_layout Plain Layout

\lyxline

\end_layout

\end_inset


\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
call
\begin_inset space ~
\end_inset

to
\begin_inset space ~
\end_inset

procedure matching
\begin_inset space ~
\end_inset

rule
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
solve(a,e) 1.
 a :- b,c,d
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

solve(b,c,d,e) no matching rule
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
solve(a,e) 2.
 a :- e,f
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

solve(e,f,e) 5.
 e
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

solve(f,e) 6.
 f
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

solve(e) 5.
 e
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

solve(NIL) write('yes'), recursion terminated
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

solve(e) no matching rule (back out of recursion, continue search)
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

solve(f,e) no match
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

solve(e,f,e) no match
\end_layout

\begin_layout List
\labelwidthstring call to procedureXXX

\family typewriter
solve(a,e) no match, finished
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength{
\backslash
columnseprule}{0.25pt}
\backslash
begin{multicols}{2}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
UNIFICATION
\end_layout

\begin_layout Standard
One reason for collecting facts in a data base is to represent relationships
 among the data items and to use those relationships to answer questions
 about the data.
 To accomplish this, we will first introduce a more convenient notation
 to represent rules and queries and then modify the 
\shape italic
solve
\shape default
 procedure to handle the new notation.
\end_layout

\begin_layout Standard
Let's consider a relatively simple data base, which contains some information
 about a few people's personal preferences:
\end_layout

\begin_layout Enumerate
likes(joan,pool).
\end_layout

\begin_layout Enumerate
likes(alice,candy).
\end_layout

\begin_layout Enumerate
female(joan).
\end_layout

\begin_layout Enumerate
female(alice).
\end_layout

\begin_layout Enumerate
male(paul).
\end_layout

\begin_layout Enumerate
likes(paul,X)
\begin_inset space ~
\end_inset

:- likes(X,pool),female(X).
\end_layout

\begin_layout Standard
Again, the numbers aren't part of the data base.
 Readers familar with PROLOG may recognise this notation.
 It is a convenient way to represent relationships.
 Line 1 may be read 
\begin_inset Quotes eld
\end_inset

Joan likes pool
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\noindent
PROLOG notation has a convention that constants such as somebody's name
 start with a lowercase letter.
 For the purpose of explanation quoted examples relax this, hence 
\begin_inset Quotes eld
\end_inset

Joan likes pool
\begin_inset Quotes erd
\end_inset

 treats 
\begin_inset Quotes eld
\end_inset

Joan
\begin_inset Quotes erd
\end_inset

 as somebody's name as is conventional in written English.
\end_layout

\end_inset

.
 
\begin_inset Quotes eld
\end_inset

Likes
\begin_inset Quotes erd
\end_inset

 is called a functor and names a relationship between the first component,
 
\begin_inset Quotes eld
\end_inset

Joan
\begin_inset Quotes erd
\end_inset

, and the second 
\begin_inset Quotes eld
\end_inset

pool
\begin_inset Quotes erd
\end_inset

.
 Line 3 says 
\begin_inset Quotes eld
\end_inset

Joan is a female
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Terms line 
\begin_inset Quotes eld
\end_inset

Joan
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

female
\begin_inset Quotes erd
\end_inset

, etc.
 are loaded with millions of associations in our minds, but here we will
 only be manipulating symbols.
 Thus the knowledge that Joan is a common female name in North America has
 no meaning unless it is defined in the data base.
\end_layout

\begin_layout Standard
Line 6 is slightly different from the others: it contains a variable.
 In PROLOG's notation, constants begin with lowercase letters and variables
 begin with uppercase letters or an underscore.
 A variable is a symbol whose value will be determined in the context of
 some query.
 Line 6 can be read 
\begin_inset Quotes eld
\end_inset

Paul likes X if X likes pool and X is female
\begin_inset Quotes erd
\end_inset

.
 Or, more simply, 
\begin_inset Quotes eld
\end_inset

Paul likes any female who likes pool
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
With this notation we form queries such as 
\begin_inset Quotes eld
\end_inset

Does Paul like Joan?
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Who does Paul like?
\begin_inset Quotes erd
\end_inset

 The former is expressed as 
\shape italic
?-
\begin_inset space ~
\end_inset

likes (paul,joan)
\shape default
 while the latter is expressed as 
\shape italic
?-
\begin_inset space ~
\end_inset

likes(paul,A)
\shape default
.
 
\shape italic
?-
\shape default
 indicates that what follows is to be treated as a query.
 The first query will cause 
\shape italic
solve
\shape default
 to respond 
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

no
\begin_inset Quotes erd
\end_inset

.
 In the second case, 
\shape italic
solve
\shape default
 should not only tell us that Paul likes someone but who that someone is.
 The process of finding a value for a variable is called binding the variable,
 and the value of the variable is often called its binding.
 The set of all the current variables and their bindings is called the environme
nt.
\end_layout

\begin_layout Standard
Of course, with the introduction of functors and variables, our previous
 version of 
\shape italic
solve
\shape default
 is inadequate.
 The problem lies in the process of matching the head of a rule against
 the head of a query.
 Consider the query 
\shape italic
?-
\begin_inset space ~
\end_inset

likes(paul,joan).

\shape default
 The head of the query is 
\shape italic
likes(paul,joan).

\shape default
 We take the functor and its components paul and joan to be a single entity.
 We can probably agree that it should not match the head of rules 1 through
 5.
 Rule 1 tells us about what joan likes, so the functors match but the first
 components don't.
 Similarly, rule 2 tells us what alice likes so it doesn't match the query.
 Rules 3, 4, and 5 aren't about likes at all so they don't match the query.
 Rule 6 is different, however.
 The functors match and the first components match, but what about joan
 and X? In a case such as this, we say that the head of rule 6 and the query
 match, with the variable X from the rule bound to joan.
\end_layout

\begin_layout Standard
Now we can continue as before.
 We append the tail of the query 
\shape italic
NIL
\shape default
 with the tail of the rule 
\shape italic
likes(X,pool),female(X).

\shape default
 and try to solve this transformed query along with the added information
 that X is bound to joan.
 The new query could be interpreted as 
\shape italic
likes(joan,pool),female(joan).
\end_layout

\begin_layout Standard
Suppose instead we had posed the query 
\shape italic
?-
\begin_inset space ~
\end_inset

likes(paul,A).

\shape default
 Rules 1 through 5 still don't provide us with a match but the head of rule
 6 will match, provided we can bind 
\shape italic
X
\shape default
 to 
\shape italic
A
\shape default
.
 When one variable is bound to another, we say that the variables share
 a binding.
 When one is matched to a constant, the other automatically takes on the
 same value.
\end_layout

\begin_layout Standard
We still have one complication to consider.
 What would happen if we were to add a new rule to the data base, for example,
 
\shape italic
likes(joan,X)
\begin_inset space ~
\end_inset

:- likes(X,candy)
\shape default
? Are the 
\shape italic
X
\shape default
s in this rule the same as in rule 6? Or suppose we has posed the query
 as 
\shape italic
?-
\begin_inset space ~
\end_inset

likes(paul,X)
\shape default
.
 Is the 
\shape italic
X
\shape default
 in the query the same one that appears in the rules? Questions like this
 are really an informal way of asking what the scope of a variable is.
 A variable's scope is the range over which its bindings are valid.
 Readers who are familiar with block-structured languages like Pascal or
 C understand the concept of scope.
 In a block-structured language a variable's scope is the block in which
 it is defined.
 That makes it possible to define a local variable, like 
\shape italic
X
\shape default
, in a procedure and also to define another local variable with the same
 name in another procedure.
 Since these variables have different scopes, they are different variables.
\end_layout

\begin_layout Standard
In PROLOG, a variable's scope is the rule or query that contains it.
 This means that in 
\shape italic
likes(paul,X)
\begin_inset space ~
\end_inset

:- likes(X,pool),female(X).
\shape default
, each instance of 
\shape italic
X
\shape default
 represents the same variable.
 That variable is entirely different from the 
\shape italic
X
\shape default
 defined in 
\shape italic
?-
\begin_inset space ~
\end_inset

likes(paul,X).

\shape default
 In order to avoid confusion among variables with the same name but entirely
 different meanings, we will have 
\shape italic
solve
\shape default
 make a copy of the rule being examined.
 The copy will be exactly the same as the original rule in the data base
 but all variables in the rule will be tagged by appending the recursion
 level to them.
 Since a rule either fails or causes a recursive call to solve, this will
 mean that when seeking the resolution of a query, each time a rule is encounter
ed its variables will have unique names.
 Listing 3
\begin_inset CommandInset ref
LatexCommand ref
reference "Listing 3"

\end_inset

 contains the new version of 
\shape italic
solve
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{-1
\backslash
parskip}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "67col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
LISTING 3
\begin_inset CommandInset label
LatexCommand label
name "Listing 3"

\end_inset

: 
\shape italic
Solve
\shape default
 procedure using unification.
\end_layout

\begin_layout Plain Layout

\lyxline

\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
\noindent
PROCEDURE solve(query,env,level) ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 VAR
\begin_inset Newline newline
\end_inset

  i : integer ;
\begin_inset Newline newline
\end_inset

  new_env : same as query and env ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 BEGIN
\begin_inset Newline newline
\end_inset

  IF query = NIL
\begin_inset Newline newline
\end_inset

   THEN print_env(env)
\begin_inset Newline newline
\end_inset

   ELSE
\begin_inset Newline newline
\end_inset

    FOR i := 1 TO max_rule_number DO
\begin_inset Newline newline
\end_inset

     IF unify(copy(head(rule[i]),level+1),head(query),env,new_env)
\begin_inset Newline newline
\end_inset

      THEN solve(append(copy(tail(rule[i]),level+1),tail(query)),new_env,level+1
) ;
\begin_inset Newline newline
\end_inset

END ; (* solve *)
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength{
\backslash
columnseprule}{0.25pt}
\backslash
begin{multicols}{2}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\shape italic
Solve
\shape default
 is called with the current query as before.
 Two additional parameters are included with each call: 
\shape italic
env
\shape default
, the current environment, and 
\shape italic
level
\shape default
, an integer that contains the current recursion level.
 
\shape italic
Env
\shape default
 is a list of variables and their bindings.
 
\shape italic
Print_env
\shape default
 is a routine that prints the current environment.
 If a query is resolved (if some set of transformations reduce it to 
\shape italic
NIL
\shape default
), the current environment can be printed to show what set of bindings led
 to the resolution of the query.
 
\shape italic
Copy
\shape default
 is a function that is passed an object to copy and returns an integer.
 It then returns a copy of that object with the integer appended to each
 of the variables in the object.
\end_layout

\begin_layout Standard

\shape italic
Unify
\shape default
 is a Boolean function that matches the heads of sentences against the head
 of the query.
 If it returns a value of true (indicating that a match has been made) 
\shape italic
new_env
\shape default
 contains a copy of the old environment plus any new bindings that 
\shape italic
unify
\shape default
 may have made.
 (The routine is named unify rather than something like 
\shape italic
match
\shape default
 because the process of matching and binding is normally called unification.)
 
\shape italic
Unify
\shape default
 isn't particularly difficult to design.
 We'll leave aside most of its details, but Table 1
\begin_inset CommandInset ref
LatexCommand ref
reference "Table 1"

\end_inset

 indicates how rules and queries should be unified.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{-1
\backslash
parskip}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "67col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
TABLE 1
\begin_inset CommandInset label
LatexCommand label
name "Table 1"

\end_inset

: Unification of items in rules and queries.
\end_layout

\begin_layout Plain Layout

\lyxline

\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
\noindent
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features>
<column alignment="block" valignment="top" width="25line%">
<column alignment="center" valignment="top" width="75line%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ITEM WITHIN THE QUERY
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features>
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" rotate="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ITEM IN THE RULE
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features>
<column alignment="block" valignment="top" width="20line%">
<column alignment="block" valignment="top" width="25line%">
<column alignment="block" valignment="top" width="25line%">
<column alignment="block" valignment="top" width="25line%">
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constant (C2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable (V2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Functor (F2)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constant (C1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
succeed if C1 = C2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
succeed bind V2 to C1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fail
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable (V1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
succeed bind V1 to C2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
succeed bind V1 to V2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
succeed bind V1 to F2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Functor (F1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fail
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
succeed bind V2 to F1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
succeed if expressions have same functor and arity and each pair of components
 can be unified
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength{
\backslash
columnseprule}{0.25pt}
\backslash
begin{multicols}{2}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unify will have to be recursive because of the requirement to unify each
 of the components of a complex expression.
 Arity, mentioned in the table
\begin_inset CommandInset ref
LatexCommand ref
reference "Table 1"

\end_inset

, is the number of components in the expression.
\end_layout

\begin_layout Standard
This description of the interpreter is somewhat concise, so let's look at
 a few steps in the resolution of the query 
\shape italic
?-
\begin_inset space ~
\end_inset

likes(paul,A).

\shape default
 to get a better understanding of this process.
 Table 2
\begin_inset CommandInset ref
LatexCommand ref
reference "Table 2"

\end_inset

 shows the steps involved in resolving this query.
 One thing to note in this table is that when 
\shape italic
unify
\shape default
 encounters a variable it looks up that variable's binding in the current
 environment.
 If it finds a binding, it attempts to unify the binding with the parameter
 being matched.
 Thus, in attempting to unify joan with 
\shape italic
X#0
\shape default
, it will look up the binding of 
\shape italic
X#0
\shape default
 and then try to unify joan and 
\shape italic
A
\shape default
.
 Since 
\shape italic
A
\shape default
 isn't bound, these two items are unified by binding 
\shape italic
A
\shape default
 to joan.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{-1
\backslash
parskip}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "67col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
TABLE 2
\begin_inset CommandInset label
LatexCommand label
name "Table 2"

\end_inset

: Solving the query 
\shape italic
?- likes(paul,A).
\end_layout

\begin_layout Plain Layout

\lyxline

\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
\noindent
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
QUERY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ENVIRONMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LEVEL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MATCHING RULE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BIND
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
likes(paul,A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NIL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 likes(paul,X)
\begin_inset space ~
\end_inset

:- likes(X,pool),female(X)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X#0 to A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
likes(X#0,pool),female(X#0)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(X#0 A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 likes(joan,pool)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A to joan
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
female(X#0)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(A joan) (X#0 A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 female(joan)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NIL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength{
\backslash
columnseprule}{0.25pt}
\backslash
begin{multicols}{2}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although this description has been greatly simplified and does not consider
 such important concepts as how arithmetic and negation are handled, we
 hope it gives you an understanding of how simple relationships can be placed
 in a data base and the retrieved.
 If you download the program, experiment with setting up a simple relationship
 data base such as the one we've discussed, This will help you become more
 accustomed to looking at heads and tails and understanding the process
 of instantiation that makes PROLOG such a powerful symbol manipulator.
\end_layout

\begin_layout Standard
In the next issue we'll jump right in and see how to implement VT-PROLOG.
\end_layout

\begin_layout Subsubsection*
RESOURCES
\begin_inset CommandInset label
LatexCommand label
name "Resources"

\end_inset


\end_layout

\begin_layout Standard
When this article was originally published in 1986 the field of artificial
 intelligence was going through a 
\begin_inset Quotes eld
\end_inset

golden age
\begin_inset Quotes erd
\end_inset

 with extensive and well-funded research engendered, in part, by the Japanese
 Fifth Generation Computer Systems project.
\end_layout

\begin_layout Standard
The literature of PROLOG was growing rapidly.
 The basic form of the VT-PROLOG interpreter came from an article 
\begin_inset Quotes eld
\end_inset

Describing PROLOG by its Interpretation and Compilation
\begin_inset Quotes erd
\end_inset

 by Jaques Cohen, December 1985, 
\shape italic
Communications of the ACM
\shape default
.
 In the same issue was the article 
\begin_inset Quotes eld
\end_inset

PROLOG in 10 Figures
\begin_inset Quotes erd
\end_inset

 by Alain Colmerauer, one of the original developers of PROLOG.
 That article described PROLOG by means of a series of figures, both eye
 catching and informative.
 
\begin_inset Quotes eld
\end_inset

Learning about PROLOG
\begin_inset Quotes erd
\end_inset

, a useful introductory article on PROLOG by Ramachandran, Bharath and Margaret
 Sklar, appeared in the July 1985 issue of COMPUTER LANGUAGE, pp.
 49-54.
 The August 1985 issue of BYTE was dedicated to declarative languages, of
 which PROLOG was the most important example.
 PD PROLOG was a public domain interpreter available on a variety of bulletin
 board systems and was released by Automata Design Associates, 1370 Arran
 Way, Dresher, Pa.
 19025.
\end_layout

\begin_layout Standard
By 2010 there is still significant interest in PROLOG, particularly with
 the addition of constraint logic programming capabilities to several implementa
tions.
 Needless to say, the rise of the Internet with searching and indexing services
 has obviously made it far easier to find useful information and implementations
, but it is hoped that the system described in this paper is still of some
 interest.
\end_layout

\begin_layout Standard
VT-PROLOG as currently released exists in these versions:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
1.1 Original source as released in 1986, written by Bill Thompson for Turbo
 Pascal v3.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
1.2 Modified in 2010 by Mark Morgan Lloyd to compile with both v3 and v5.5.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
1.3 Modified to compile with both Turbo Pascal v5.5 and Free Pascal v2.4 (
\shape italic
forthcoming
\shape default
).
\end_layout

\begin_layout Standard
Despite being more than 20 years old it still serves as an interesting testbed
 for experimentation, and there are still areas where an individual or small
 team could make useful contributions.
\end_layout

\begin_layout Standard
For example, the majority of PROLOG implementations are inherently single-thread
ed, i.e.
 irrespective of the number of CPUs (
\begin_inset Quotes eld
\end_inset

cores
\begin_inset Quotes erd
\end_inset

) in a computer only one is actively engaged in solving a query.
 Since the major Pascal implementations support multi-threaded applications
 with ease, could this be used to provide a transparent performance boost
 to PROLOG?
\end_layout

\begin_layout Standard

\lyxline

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{-1
\backslash
parskip}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Bill and Bev Thompson are writers and consultants specialising in implementing
 AI techniques on microcomputers.
 They are the authors of MicroExpert, an expert system shell, and have worked
 extensively on knowledge-based designs.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
